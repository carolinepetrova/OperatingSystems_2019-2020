# Информационни команди. Команди за многопотребителския режим, комуникация. Команди за работа с процеси. Пренасочване на вход/изход. Конвейер между процеси. 

## Информационни команди

- `ls [-опции] [път до директория]`

- `date` - дава системно време

- `cal` - Принтира календар
	- без аргументи принтира текущия месец
		
	- `cal [месец] [година]` - принтира месеца и годината, които сме задали
	
		Пример: `cal 02 2016`

- `du [-опции] [файл/директория] ` - показва дисково пространство, заето от файлове или директории.

	- без указан файл/директория показва заеманото дисково пространство на всички файлове, директории и поддиректории на текущата директория в която се намиране
	
	
	Опции:
	
	- `-a` показва информацията и за скритите файлове
	
	- `-h` показва размера в human readable format
	
	- `-s` показва **само** размера на подадената директория

- `df [oпции] [файл]` показва кратка информация за заеманото дисково пространство на файловата система 

	 - ако бъде специфициран файл то то се показва информация за файловата система, в която се намира той 
	 
	Опции:
	
	- `-h` показва размерите в human readable format
	
	- `-k`  показва размерите в килобайти
	
	- `-m`  показва размерите в мегабайти
	
	- `-h` показва размерите в гигабайти 

- `tty`  -  показва името на файла на терминала, свързан към стандартния вход. 
	
	WTF нали ... Тъй като всичко в Линукс е файл то тогава и всички свързани устройства са представени чрез специални файлове => терминала също е представен като файл. More info.
	 

## Команди за многопотребителския режим
- `login`

- `su [username]` - сменяме потребителя или ставаме суперпотребител

- `chown [потребител] [файл/ове]` - смяна на собственик на файла

- `chgrp [група] [файл/ове] ` - смяна на групата на файла

- `chmod [режим] [файл/ове] ` -   промяна на правата за достъп до даден файл или директория
	
	Режимът може да е:
	
	- Зададен чрез число в 8-мична бройна система: 000-777. 

		**Пример:** chmod 777 f1

		**Как можем да изчислим всяка цифра?** 

		От първото упражнение знаем, че правата за достъп на файловете изглеждат така: 

		`drwxr-xr-x  2 user user 4096 окт  5  2018 directory` 
		
		` -rw-r--r--  1 user user  2243935 дек  8  2017 file`

		Като на първата позиция стои съответно индикатор дали това е директория (d) или файл (-). Следват 3 групи от 3 символа **r**ead, **w**rite, e**x**ecute, които указват правата за достъп съответно на текущия потребител, групата му и всички останали. Ако някое право е забранено съответно на мястото му присъства `-`. 

		За да получим 3-цифрения код за правата за достъп просто заместваме r,w,x с 1-ца, а `-` с 0. 

		**Примерно** `-rw-r--r--` е файл, който може да се чете и пише от текущия потребител и само да се чете от групата и всички останали. 
		След като заместим символите с 0 и 1 получаваме: `110 100 100`  и така след преобразуване в 8-мична бр. система получаваме `644`. 
	
	- Зададен чрез букви: следва следния синтаксис: [Кой] [Действие] [Какво]
		- Кой: **u**ser, **g**roup, **o**thers, **a**ll
			
		- Действие: **+** добавя право, **-** премахва право, **=** сменя изцяло правата за достъп с тези, който стоят от дясната страна на равенството
			
		- Какво: **r**ead, **w**rite, e**x**ecute

		**Примери:**
		
		`chmod u=rw,og=r file.txt` - текущия потребител получава правото само да чете и да пише, а групата и всички останали само да четат
		
		`chmod a+wx script.sh` - всички получават право да пишат и изпълняват файла
		
		`chmod go+w *` - групата и всички останали получават право да пишат по всички файлове в текущата директория
		
### Комуникация между потребители
- `who` - показва информация за логнатите потребители

- `whoami` - показва името на потребителя, изпълнил командата

- `w` - показва информация за логнатите потребители и какво правят в момента

- `finger [потребител]`  - показва информация за даден потребител

	-  ако не е указано потребителско име показва информация за всички потребители

- `wall` - пишем съобщение до всички

- `mesg [y|n]` - разрешава/забранява получаването на съобщения от други потребители 

	- без аргументи, командата показва информация дали сме разрешили или забранили съобщения
	
	- `mesg y` - разрешава съобщения
	
	- `mesg n` - забранява съобщения  


- `write [user] [tty]` - пишем съобщение до даден user като можем да укажем и по кой терминал да му се прати, ако user-a е логнат в повече от един. Ако потребителя е забранил съобщенията си излиза грешка.  

## Команди за работа с процеси

- `ps` - показва всички текущи процеси на текущия потребител

- `ps aux` - показва информация за всички процеси на всички потребители

	**Каква информация виждаме?** 

	- USER - на кой потребител принадлежи процеса
	
	- PID - идентификационен номер на процеса
	
	- %CPU - използваното време на процесора, разделено на времето, в което е стартиран процесът.

	 - %MEM  - процент на реалната памет, използвана от процеса.

	- VSZ   - използване на виртуална памет за целия процес (в KiB)
	
	- RSS - незаменяемата физическа памет, която е използвана в задачата (в KiB)

	- TTY  - контролиращ терминал
	
	- STAT - кодът на състоянието на процеса, който може да бъде Z (зомби), S (спящ), R (работещ) и т.н.
	
	- START  - начално време на процеса
	
	- TIME - количество време на процесора, изразходвано за изпълнение на процеса

	- COMMAND - името на изпълнената команда с нейните опции 

- `kill [опции] [pid на процес] ` - изпраща сигнал на процес
	
	**Какво е сигнал?** 

	Сигналите са предупреждения за важни събития, изпращани към процесите от ядрото или от друг процес. Те прекъсват дейността на процеса и го принуждават да ги обработи веднага.  Всички сигнали могат да бъдат изведени чрез `kill -l`

	**По-важни сигнали:**

	- SIGHUP  с номер 1 -  изпраща се от ядрото при отписване на потребителя. 

	- SIGINT с номер 2  - прекъсване. Изпраща се от ядрото при въвеждане  **Ctrl+C**  на терминала.

	- SIGKILL с номер  9 - принуждава процеса да завърши без да му се дава възможност за нормална завършваща дейност.
	
	- SIGTERM с номер 15  - заявка за нормално приключване на процеса.

	- TSTP с номер 18 - временно прекратява действието на процеса. Изпраща се от ядрото при въвеждане  **Ctrl+Z**  на терминала.

	**Пример:** 
	
	`kill -9 1234` - убиваме процес с pid 1234


## Пренасочване на вход/изход

При стартирането на процес той предварително е свързан с 3 [комуникационни канала](https://bg.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D1%83%D0%BD%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B5%D0%BD_%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB) (файла) - stdin (стандартен вход), stdout (стандартен изход), stderr (стандартен изход за грешки). 

Стандартните потоци на процесите могат да бъдат пренасочвани във файлове:

- Стандартният вход (stdin) се пренасочва чрез "<" към файл, откъдето процесът трябва да чете
	
	Пример: когато използваме cat без аргументи, командата чете низове от стандартния вход и ги принтира на стандартния изход. 
	
	`cat < f1` - stdin за cat става файла f1, а stdout си е стандартния изход. Командата извежда съдържанието на файла. 

- Стандартния изход (stdout) се пренасочва с ">" към файл. Ако файлът не съществува се създава, иначе се презаписва. Ако не искаме файла да се презаписва, а да добавяме към края му, се използва ">>". 

	`cat > f1` - стандартния вход е клавиатурата, а стандартния изход става файлът f1, т.е. пишем последователно във файла f1. 
	
	`ps aux >> f1` - стандартния изход за ps aux става файла f1, като сме указали информацията да се добави към края на съдържанието му. 

- можем да пренасочим и двата потока едновременно

	`cat < f1 > f2` - stdin за cat е f1, a stdout е f2, т.е. симулирахме cp командата

**Какво става със стандартния поток за грешки?** 

Ако изпълним командата `find / -name f1 > ff` виждаме че stdout е пренасочен към файла ff, a на екрана ни излизат само съобщения за грешки. Най-често стандартния поток за грешки се пренасочва чрез **файловия му дескриптор**

**Какво е файлов дескриптор?**

Файловият дескриптор е цяло, неотрицателно число, което служи за идентифициране на отворен файл. 

Както споменах по-горе всеки процес има 3 предварително отворени файла: 
	- stdin е с дескриптор 0 
	- stdout е с дексриптор 1
	- stderr е с дескриптор 2

Всеки процес може да отваря и други файлове, като на тях ще им се присвоява съответно най-малкото свободно число ... но това е тема, която ще се разглежда по Системно програмиране. 

Та горните примери съответно могат да изглеждат по този начин:

`cat 0<f1` - принтираме съдържанието на f1

`cat 1>f1` - записваме низове, подадени от стандартния вход в f1

`ps aux 1>>f1` - записваме информацията от ps aux в края на f1 

И съответно, за да пренасочим грешките в друг файл:

`find / -name f1 > ff 2>errors.txt` - така имаме файл ff, който съдържа желаните резултати и файл errors.txt, който съдържа всички грешки от изпълнението на find. 

## Конвейер между процеси. 

Конвейерът е последователност от процеси, свързани чрез техните потоци, така че стандартния изход от единия процес става стандартен вход на следващия процес. 

Синтаксисът е следният: `command1 | command 2 | command 3` 

Пример: Искаме да преброим колко файла имаме в текущата директория. Това може да стане по следния начин:

    ls -l > temp
    wc -l < temp 
    rm temp

Вместо да създаваме временен файл можем да свържем стандартния изход на ls със стандартния вход на wc: 

    ls -l | wc -l
