# Системни примитиви за работа с файлове в Linux

**Как да компилираме C програма?**
```
cc file.c -o nameof_output_executable
```

## Oсновни понятия
**Файлов дескриптор** - Неотрицателно цяло число, което служи за уникален идентификатор на отворен файл. Всеки процес стандартно има отворени три дескриптора:
-   0 (стандартен вход)

-   1 (стандартен изход)

-   2 (стандартен изход за грешки)

**Текуща позиция във файл** (**file offset**) - Определя позицията на файла за четене и писане (един указател за двете действия).

**Режим на отваряне** - Указва режима, в който е отворен даден дескриптор.

## Системни примитиви за работа с (обикновени) файлове

### Създаване на файл
```
int creat(const char *filename, mode_t mode);
```

- Създава обикновен файл с име **filename** с режим **mode**.

- Връща дескриптора на файла или -1 при грешка.

### Отваряне на файл
```
#include <fcntl.h>
int open(const char *filename, int oflag [, mode_t mode]);
```

- Отваря файл с име **filename** в режим **oflag**, а ако не съществува го създава с режим **mode**.

- връща файловия дескриптор или -1 при неуспех

**oflag** указва режима на отваряне и/или действия, които да се извършат след отваряне:

-   O_RDONLY - само за четене

-   O_WRONLY - само за писане

-   O_RDWR - за четене и писане

-   O_CREAT - създава файла

-   O_EXCL - заедно с O_CREAT: ако файлът  **не съществува**, той се създава, иначе се връща грешка

-   O_TRUNC - старото съдържание на файла се изтрива след отваряне

-   O_APPEND - старото съдържание се запазва, а новото се вписва в края на файла

-   O_SYNC - всяко писане е синхронно 

**Задача:** Да се създаде C програма, която отваря файл с име cFile само за четене. Ако файлът не съществува, то той да бъде създаден с режим 0644, а иначе да бъде изтрито неговото съдържание.

### Четене от файл

```
#include <unistd.h>
ssize_t read(int  _fildes_**, void ***_buf_**, size_t**  _nbyte_**);  
```
-   **fd**  - номер на файлов дескриптор

-   **buffer**  - указател към  областта от програмата, където се записват данните

-   **nbytes**  - указва броя байтове за четене

- връща броя на **реално** прочетените байтове, иначе връща -1

### Писане във файл

```
ssize_t write(int fd, void *buffer, size_t nbytes);
```
-   **fd**  - номер на файлов дескриптор

-   **buffer**  - указател към  областта от програмата, където се записват данните

-   **nbytes**  - указва броя байтове за писане

- връща броя на **реално** записаните байтове, иначе връща -1 

### Позициониране във файл

```
off_t lseek(int fd, off_t offset, int flag);
```

-   **fd**  - номер на файлов дескриптор

- **offset** - самото отместване

- **flag** -  указва как се интерпретира отместването

	- **SEEK_SET** - премества указателя от началото до offset-байта

	- **SEEK_CUR** - премества указателя от сегашната му позиция до offset-байта

	-  **SEEK_END** - премества указателя от края на файла (отзад-напред) до offset-байта

### Затваряне на файл

```
int close(int fd);
```

## Задачи: 
1. Реализирайте cp командата т.е приема от командния ред имена на 2 файла и копира съдържанието на първия във втория. 
2. Чете последователност от символи от стандартния вход. Записва ги във файл, чието име е подадено като първи параметър. Замества символите за табулация с '>>>' и резултата извежда на стандартния изход за грешки.
3. Чете последователност от символи от файл, чието име е подадено като първи параметър. Извежда ги на стандартния изход. Първите 3 символа от всеки ред добавя след края на файл, чието име е подадено като втори параметър.
